import re
from pathlib import Path

def clean_csv_record(line: str) -> str:
    """
    Очищает строку CSV:
    - Убирает лишние пробелы
    - Убирает пробелы вокруг запятых и знака равенства
    """
    line = line.rstrip('\r\n')
    # объединяем более двух пробелов в один
    line = re.sub(r"\s{2,}", " ", line)
    # убираем пробелы вокруг запятых и =
    line = re.sub(r"\s*,\s*", ",", line)
    line = re.sub(r"\s*=\s*", "=", line)
    return line


def process_file(input_path: Path, output_path: Path) -> None:
    """
    Читает input_path, соединяет разбитые записи и записывает очищенный CSV в output_path.
    Каждая запись на отдельной строке, записи начинаются с числа.
    """
    new_record = re.compile(r"^\d+,")
    output_lines = []
    buffer = []

    with input_path.open('r', encoding='utf-8') as fin:
        for raw in fin:
            cleaned = clean_csv_record(raw)
            if new_record.match(cleaned):
                if buffer:
                    # добавляем накопленную запись
                    output_lines.append(''.join(buffer))
                buffer = [cleaned]
            else:
                buffer.append(cleaned)

    # добавляем последнюю запись
    if buffer:
        output_lines.append(''.join(buffer))

    # создаем папку, если ее нет
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with output_path.open('w', encoding='utf-8', newline='\n') as fout:
        fout.write("\n".join(output_lines))


def start_parsing():
    raw_dir = Path('./исходные данные')
    out_dir = Path('./после парсинга')
    pattern = 'MOCK_DATA*.csv'

    files = sorted(raw_dir.glob(pattern))
    if not files:
        print(f"Нет файлов по шаблону {pattern} в {raw_dir}")
        return

    for inp in files:
        out_name = f"parsed_mock{files.index(inp)+1}.csv"
        out_path = out_dir / out_name
        print(f"Обработка {inp} → {out_path}")
        process_file(inp, out_path)

    print("Готово!")